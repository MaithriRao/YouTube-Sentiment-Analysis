name: workflow

on:
  push:
    branches:
      - master
    paths-ignore:
      - 'README.md'

permissions:
  id-token: write
  contents: read

jobs:
  integration:
    name: Continuous Integration
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Lint code
        run: echo "Linting repository"

      - name: Run unit tests
        run: echo "Running unit tests"

  build-and-push-ecr-image:
    name: Continuous Delivery
    needs: integration
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Install Utilities
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_NAME }}
          IMAGE_TAG: latest
        run: |
          # Build a docker container and
          # push it to ECR so that it can
          # be deployed to ECS.
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "::set-output name=image::$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          
          
  Continuous-Deployment:
    needs: build-and-push-ecr-image
    runs-on: self-hosted
    steps:
      - name: Checkout
        uses: actions/checkout@v3

          # extra added 
      - name: Stop and remove old container (Failure Tolerant Cleanup)
        run: |
          echo "Attempting to stop and remove cnncls container..."
          docker stop cnncls || true
          docker rm -fv cnncls || true
          echo "Cleanup attempt complete."
          
         # extra added 

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Pull and Run new container (Updated with correct ports and environment variables)
        run: |
          # The ECR_IMAGE variable holds the full URI from the previous job's output.
          ECR_IMAGE=${{ needs.build-and-push-ecr-image.outputs.ecr_image }}
          echo "Pulling new image: $ECR_IMAGE"
          docker pull $ECR_IMAGE
          
          # Running the container with the correct 8080:8080 port mapping and 
          # setting all necessary environment variables as per your original file.
          echo "Starting container cnncls on port 8080"
          docker run -d -p 8080:8080 --name=cnncls \
          -e 'AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}' \
          -e 'AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}' \
          -e 'AWS_REGION=${{ secrets.AWS_REGION }}' \
          $ECR_IMAGE
          
          echo "Deployment successful."
      
      
      # - name: Pull latest images
      #   run: |
      #    docker pull ${{secrets.AWS_ECR_LOGIN_URI}}/${{ secrets.ECR_REPOSITORY_NAME }}:latest
         
      # - name: Stop and remove container if running
      #   run: |
      #    docker ps -q --filter "name=cnncls" | grep -q . && docker stop cnncls && docker rm -fv cnncls
       
      # - name: Run Docker Image to serve users
      #   run: |
      #    docker run -d -p 8080:8080 --name=cnncls -e 'AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}' -e 'AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}' -e 'AWS_REGION=${{ secrets.AWS_REGION }}'  ${{secrets.AWS_ECR_LOGIN_URI}}/${{ secrets.ECR_REPOSITORY_NAME }}:latest
      
      - name: Clean previous images and containers
        run: |
         docker system prune -f

# name: YouTube Sentiment Analysis Deployment

# on:
#   push:
#     branches:
#       - master # Trigger the workflow on pushes to the master branch
#     paths-ignore:
#       - 'README.md'

# permissions:
#   # Allows JWT access for OIDC provider (for secure AWS credentials)
#   id-token: write
#   # Allows cloning the repository content
#   contents: read

# jobs:
#   # ----------------------------------------------------------------------
#   # 1. Continuous Integration (CI) - Runs on GitHub's Hosted Runner
#   # ----------------------------------------------------------------------
#   integration:
#     name: Continuous Integration
#     runs-on: ubuntu-latest
#     steps:
#       - name: Checkout Code
#         uses: actions/checkout@v4 # Recommended to use the latest version

#       - name: Lint code
#         # Placeholder for actual linting commands (e.g., flake8, pylint)
#         run: echo "Linting repository"

#       - name: Run unit tests
#         # Placeholder for actual test commands (e.g., pytest)
#         run: echo "Running unit tests"

#   # ----------------------------------------------------------------------
#   # 2. Build and Push Docker Image to ECR
#   # ----------------------------------------------------------------------
#   build-and-push-ecr-image:
#     name: Build & Push Image
#     needs: integration # Depends on CI passing
#     runs-on: ubuntu-latest
#     steps:
#       - name: Checkout Code
#         uses: actions/checkout@v4

#       # Install necessary utilities for AWS commands (jq is often pre-installed, but harmless to specify)
#       - name: Install Utilities
#         run: |
#           sudo apt-get update
#           sudo apt-get install -y jq unzip

#       - name: Configure AWS credentials
#         uses: aws-actions/configure-aws-credentials@v4 # Recommended to use the latest version
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           # AWS_REGION MUST be specified here to avoid issues with ECR login
#           aws-region: ${{ secrets.AWS_REGION }} 

#       - name: Login to Amazon ECR
#         id: login-ecr
#         uses: aws-actions/amazon-ecr-login@v2 # Recommended to use the latest version

#       - name: Build, tag, and push image to Amazon ECR
#         id: build-image
#         env:
#           ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
#           ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_NAME }}
#           IMAGE_TAG: latest
#         run: |
#           # The ECR login URI is derived from the registry output
#           # Docker build using the Dockerfile in the repo root
#           docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
#           docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
#           # Save the full image URI as an output for the next job
#           echo "IMAGE_URI=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT 
#         # CRITICAL FIX: Changed '::set-output name=image::' to the correct GITHUB_OUTPUT method
          
#   # ----------------------------------------------------------------------
#   # 3. Continuous Deployment (CD) - Runs on your Self-Hosted EC2 Runner
#   # ----------------------------------------------------------------------
#   Continuous-Deployment:
#     name: Deploy to EC2 Runner
#     needs: build-and-push-ecr-image # Depends on image being pushed to ECR
#     # CRITICAL FIX 1: Pass outputs from the previous job to this job
#     # Use 'env' context to retrieve the full image URI from the previous job's output
#     env:
#       IMAGE_TO_DEPLOY: ${{ needs.build-and-push-ecr-image.outputs.IMAGE_URI }}
    
#     # Use the 'self-hosted' runner group you set up
#     runs-on: self-hosted 
    
#     steps:
#       - name: Checkout Code (Needed for runner context)
#         uses: actions/checkout@v4

#       # CRITICAL FIX 2: You don't need to re-configure AWS credentials or log into ECR 
#       # just to pull the image on the EC2 runner. Since you are using the runner, 
#       # the credentials should be managed via Docker's local configuration or 
#       # by passing the secrets to the docker run command (as done below).
#       # If the EC2 instance has an IAM role that allows ECR read access, 
#       # you don't need any of the AWS actions here. 
#       # For simplicity and robustness, we will perform a *direct* docker login 
#       # on the self-hosted runner which usually has a faster path to AWS services.

#       - name: AWS ECR Docker Login (Using AWS CLI method)
#         # Assuming AWS CLI is installed on your EC2 runner
#         # This securely logs Docker into ECR registry using the AWS CLI helper
#         run: |
#           aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ needs.build-and-push-ecr-image.outputs.ECR_REGISTRY }}

#       - name: Pull latest image
#         # Use the fully qualified image URI from the build job output
#         run: |
#          docker pull ${{ needs.build-and-push-ecr-image.outputs.IMAGE_URI }}
         
#       - name: Stop and remove container if running
#         run: |
#          # Only remove the container if it exists, use -f (force)
#          docker ps -a --filter "name=cnncls" | grep -q . && docker stop cnncls && docker rm -f cnncls || true
       
#       - name: Run Docker Image to serve users
#         # Run on port 5000 since your popup.js uses http://localhost:5000
#         run: |
#          docker run -d -p 5000:5000 --name=cnncls -e 'AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}' -e 'AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}' -e 'AWS_REGION=${{ secrets.AWS_REGION }}'  ${{ needs.build-and-push-ecr-image.outputs.IMAGE_URI }}

#       - name: Clean previous images and containers
#         # Pruning system images and unused volumes to save disk space
#         run: |
#          docker system prune -a -f
